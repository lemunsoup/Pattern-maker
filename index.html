<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pattern Generator v17 (Drag Final)</title>
    <style>
        /* --- CSS ìŠ¤íƒ€ì¼ --- */
        body { margin: 0; display: flex; height: 100vh; font-family: 'Segoe UI', sans-serif; overflow: hidden; background: #222; }
        
        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: #f1f1f1; }
        ::-webkit-scrollbar-thumb { background: #ccc; border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: #aaa; }

        #sidebar {
            width: 380px; 
            min-width: 380px;
            background: #f8f9fa;
            border-right: 1px solid #444;
            display: flex;
            flex-direction: column;
            z-index: 10;
        }

        .sidebar-header { padding: 20px; background: #fff; border-bottom: 1px solid #ddd; }
        .sidebar-content { flex-grow: 1; padding: 15px; overflow-y: auto; background: #f4f4f4; }
        .sidebar-footer { padding: 15px; background: #fff; border-top: 1px solid #ddd; }

        #canvas-container {
            flex-grow: 1;
            background: #1e1e1e; 
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
        }
        canvas { background: white; box-shadow: 0 0 50px rgba(0,0,0,0.5); }

        h2 { margin: 0 0 10px 0; font-size: 1.4rem; color: #333; }
        h3 { margin: 0 0 10px 0; font-size: 0.85rem; color: #666; text-transform: uppercase; font-weight: 700; letter-spacing: 0.5px; }
        label { font-size: 0.8rem; font-weight: 600; color: #555; display: block; margin-bottom: 4px; }

        .add-btn-group { display: grid; grid-template-columns: repeat(5, 1fr); gap: 4px; margin-bottom: 15px; }
        .add-btn {
            padding: 8px 4px; cursor: pointer; border: 1px solid #ccc; background: #fff; border-radius: 4px; 
            font-size: 0.75rem; transition: 0.2s; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
        }
        .add-btn:hover { background: #333; color: white; border-color: #333; }

        #download-btn {
            width: 100%; padding: 12px; background: #007bff; color: white; border: none; border-radius: 4px; font-weight: bold; cursor: pointer;
        }
        #download-btn:hover { background: #0056b3; }

        /* ë ˆì´ì–´ ì¹´ë“œ */
        .layer-card {
            background: white;
            border: 1px solid #ddd;
            border-radius: 8px;
            margin-bottom: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
            overflow: hidden;
            transition: opacity 0.2s, border 0.1s;
        }

        /* ë“œë˜ê·¸ ì¤‘ì¸ ì›ë³¸ ì¹´ë“œ (ë°˜íˆ¬ëª…) */
        .layer-card.dragging-source { 
            opacity: 0.3; 
            background: #f0f0f0;
            border: 2px dashed #999;
        }
        
        /* [ì¤‘ìš”] ë“œë¡­ ìœ„ì¹˜ í‘œì‹œì„  (ê°•ì œ ì ìš©) */
        .layer-card.drag-over-top { 
            border-top: 4px solid #000 !important; 
            margin-top: -2px; /* ìœ„ì¹˜ ë³´ì • */
        }
        .layer-card.drag-over-bottom { 
            border-bottom: 4px solid #000 !important; 
            margin-bottom: -2px;
        }

        /* í—¤ë” ìŠ¤íƒ€ì¼ */
        .layer-header { 
            display: flex; align-items: center; 
            padding: 10px 12px; 
            background: #fff; 
            /* [ì¤‘ìš”] í—¤ë”ë§Œ ë“œë˜ê·¸ ê°€ëŠ¥í•˜ë‹¤ê³  ëª…ì‹œ */
            cursor: grab; 
            user-select: none;
        }
        .layer-header:active { cursor: grabbing; background: #f8f9fa; } 
        .layer-header:hover { background: #f8f9fa; }
        
        .toggle-icon { margin-right: 8px; font-size: 0.8rem; color: #888; transition: transform 0.2s; }
        .layer-card.collapsed .toggle-icon { transform: rotate(-90deg); }

        .drag-handle { padding: 0 8px 0 0; color: #aaa; font-size: 1.2rem; line-height: 1; }
        
        .layer-title { font-weight: bold; font-size: 0.9rem; flex-grow: 1; display: flex; align-items: center; gap: 6px; }
        .delete-btn { color: #aaa; cursor: pointer; border: none; background: none; font-size: 1.2rem; margin-left: 8px; }
        .delete-btn:hover { color: #ff4757; }

        /* ë‚´ìš© ì˜ì—­: ë“œë˜ê·¸ì™€ ë¬´ê´€í•œ ì˜ì—­ */
        .layer-content {
            padding: 12px;
            border-top: 1px solid #eee;
            background: #fff;
            cursor: default; 
        }
        .layer-card.collapsed .layer-content { display: none; }


        .control-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; row-gap: 12px; }
        .full-width { grid-column: span 2; }
        .half-width { grid-column: span 1; }

        input[type="range"] { width: 100%; cursor: pointer; margin: 0; vertical-align: middle;}
        input[type="color"] { width: 100%; height: 28px; border: none; padding: 0; cursor: pointer; border-radius: 3px; }
        select { width: 100%; padding: 4px; font-size: 0.8rem; border-radius: 3px; border: 1px solid #ccc; }
        input[type="checkbox"] { vertical-align: middle; margin-right: 5px; cursor: pointer; }
        input[type="file"] { font-size: 0.75rem; width: 100%; }
        input[type="number"] { width: 50px; padding: 3px; border: 1px solid #ddd; border-radius: 3px; font-size: 0.8rem; text-align: right; }
        
        .slider-input-group { display: flex; align-items: center; gap: 8px; }
        .slider-input-group input[type="range"] { flex-grow: 1; }
        .label-with-tool { display: flex; align-items: center; justify-content: space-between; width: 100%; }
        .shuffle-tool { display: inline-flex; align-items: center; gap: 8px; }
        .shuffle-btn {
            background: #f1f3f5; border: 1px solid #ced4da; border-radius: 4px; padding: 2px 6px; font-size: 0.7rem; color: #495057; cursor: pointer; display: none;
        }
        input:checked ~ .shuffle-btn, .shuffle-btn.active { display: inline-block; }

    </style>
</head>
<body>

    <div id="sidebar">
        <div class="sidebar-header">
            <h2>Pattern Pro v17</h2>
            <div style="font-size:0.8rem; color:#666;">
                íšŒìƒ‰ ë°”ë¥¼ ì¡ì•„ì•¼ë§Œ ë“œë˜ê·¸ê°€ ë©ë‹ˆë‹¤.<br>
                <b>ëª©ë¡ ìƒë‹¨ = í™”ë©´ ë§¨ ì• (Front)</b>
            </div>
        </div>

        <div class="sidebar-content">
            <h3>Add Element</h3>
            <div class="add-btn-group">
                <button class="add-btn" onclick="addLayer('circle')">â— ì›</button>
                <button class="add-btn" onclick="addLayer('triangle')">â–² ì‚¼ê°í˜•</button>
                <button class="add-btn" onclick="addLayer('square')">â–  ì •ì‚¬ê°</button>
                <button class="add-btn" onclick="addLayer('rect')">â–¬ ì§ì‚¬ê°</button>
                <button class="add-btn" onclick="addLayer('image')">ğŸ“· ì´ë¯¸ì§€</button>
            </div>
            
            <h3 style="margin-top:20px;">Layers</h3>
            <div id="layer-list"></div>
        </div>

        <div class="sidebar-footer">
            <button id="download-btn">JPG ì €ì¥</button>
        </div>
    </div>

    <div id="canvas-container">
        <canvas id="patternCanvas"></canvas>
    </div>

    <script>
        const canvas = document.getElementById('patternCanvas');
        const ctx = canvas.getContext('2d');
        const container = document.getElementById('canvas-container');
        const layerListEl = document.getElementById('layer-list');

        const palette = ['#FF6B6B', '#4ECDC4', '#45B7D1', '#FFA07A', '#98D8C8', '#D6A2E8', '#FFD93D', '#6C5CE7', '#2d3436', '#0984e3'];
        const CACHE_SIZE = 2000;

        let state = { layers: [] };

        // ë“œë˜ê·¸ ë³€ìˆ˜
        let draggedIndex = null;
        let dropIndex = null;
        let dropPos = null; 

        function init() {
            addLayer('circle'); 
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
            document.getElementById('download-btn').addEventListener('click', downloadImage);
        }

        function generateRandomCache() {
            const cache = [];
            for (let i = 0; i < CACHE_SIZE; i++) {
                cache.push({
                    color: palette[Math.floor(Math.random() * palette.length)],
                    scale: 0.5 + Math.random() * 0.8,
                    angle: Math.random() * 2 * Math.PI
                });
            }
            return cache;
        }

        function addLayer(type) {
            const id = Date.now();
            const newLayer = {
                id: id,
                type: type, 
                collapsed: false, 
                blendMode: 'source-over',
                color: palette[Math.floor(Math.random() * palette.length)],
                gridSpacing: 80, 
                randomColor: true,
                randomSize: false,
                randomRotate: false,
                randomData: generateRandomCache(),
                size: 70, width: 70, height: 30,
                rotation: 0,
                offsetX: 0, offsetY: 0,
                imgSrc: null, 
                imgObj: null 
            };
            state.layers.push(newLayer); 
            renderLayerUI();
            draw();
        }

        function removeLayer(id) {
            state.layers = state.layers.filter(l => l.id !== id);
            renderLayerUI();
            draw();
        }

        function toggleLayer(id) {
            const layer = state.layers.find(l => l.id === id);
            if(layer) {
                layer.collapsed = !layer.collapsed;
                renderLayerUI(); 
            }
        }

        function shuffleLayer(id) {
            const layer = state.layers.find(l => l.id === id);
            if(layer) {
                layer.randomData = generateRandomCache();
                draw();
            }
        }

        function handleImageUpload(id, input) {
            if (input.files && input.files[0]) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    const img = new Image();
                    img.src = e.target.result;
                    img.onload = function() {
                        const layer = state.layers.find(l => l.id === id);
                        if(layer) {
                            layer.imgSrc = e.target.result;
                            layer.imgObj = img;
                            draw();
                        }
                    }
                }
                reader.readAsDataURL(input.files[0]);
            }
        }

        function updateLayer(id, key, value, inputType) {
            const layer = state.layers.find(l => l.id === id);
            if (layer) {
                layer[key] = value;
                if (inputType) {
                    const siblingSelector = inputType === 'slider' ? `.input-number-${id}-${key}` : `.input-slider-${id}-${key}`;
                    const sibling = document.querySelector(siblingSelector);
                    if(sibling) sibling.value = value;
                }
                if(inputType === 'checkbox') setTimeout(renderLayerUI, 0);
                draw();
            }
        }

        // ===============================================
        // [Final Fix] í—¤ë” ì „ìš© ë“œë˜ê·¸ í•¸ë“¤ëŸ¬
        // ===============================================

        function handleDragStart(e) {
            // í—¤ë” ìš”ì†Œ ìì²´(this)ê°€ ë“œë˜ê·¸ë˜ë¯€ë¡œ ì¶”ê°€ ê²€ì¦ ë¶ˆí•„ìš”
            
            // ë°ì´í„° ì„¤ì •
            draggedIndex = +this.dataset.index;
            
            // [ì¤‘ìš”] ë¶€ëª¨ ì¹´ë“œ(ì „ì²´ ëª¨ì–‘)ë¥¼ ì‹œê°ì  ë“œë˜ê·¸ ì´ë¯¸ì§€ë¡œ ì„¤ì •
            // í—¤ë”ë§Œ ì¡ê³  ëŒì§€ë§Œ, ì‚¬ìš©ìëŠ” ì¹´ë“œê°€ ëŒë ¤ì˜¤ëŠ” ê²ƒì²˜ëŸ¼ ë³´ì„
            const card = this.closest('.layer-card');
            card.classList.add('dragging-source');
            e.dataTransfer.setDragImage(card, 0, 0);
            
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/plain', draggedIndex);
        }

        function handleDragEnd(e) {
            // ë“œë˜ê·¸ ëë‚  ë•Œ íš¨ê³¼ ì œê±°
            const card = this.closest('.layer-card');
            if(card) card.classList.remove('dragging-source');
            
            // ëª¨ë“  ë“œë¡­ íƒ€ê²Ÿ í‘œì‹œ ì œê±°
            document.querySelectorAll('.layer-card').forEach(c => {
                c.classList.remove('drag-over-top', 'drag-over-bottom');
            });
            
            draggedIndex = null;
        }

        // ì—¬ê¸°ëŠ” Drop Target(ì¹´ë“œ ì „ì²´)ì— ëŒ€í•œ ì´ë²¤íŠ¸
        function handleDragOver(e) {
            e.preventDefault(); // ë“œë¡­ í—ˆìš©
            
            const card = e.currentTarget; // ì´ë²¤íŠ¸ë¥¼ ë°”ì¸ë”©í•œ ì¹´ë“œ ìš”ì†Œ
            const rect = card.getBoundingClientRect();
            const midpoint = rect.top + rect.height / 2;
            
            card.classList.remove('drag-over-top', 'drag-over-bottom');
            
            // ìƒë‹¨/í•˜ë‹¨ ê°ì§€
            if (e.clientY < midpoint) {
                card.classList.add('drag-over-top');
                dropPos = 'top'; 
            } else {
                card.classList.add('drag-over-bottom');
                dropPos = 'bottom';
            }
            dropIndex = +card.dataset.index;
        }

        function handleDragLeave(e) {
            e.currentTarget.classList.remove('drag-over-top', 'drag-over-bottom');
        }

        function handleDrop(e) {
            e.stopPropagation();
            e.preventDefault();
            
            const card = e.currentTarget;
            card.classList.remove('drag-over-top', 'drag-over-bottom');

            if (draggedIndex !== null && dropIndex !== null && draggedIndex !== dropIndex) {
                const itemToMove = state.layers[draggedIndex];
                
                // 1. ì œê±°
                state.layers.splice(draggedIndex, 1);
                
                // 2. ì‚½ì… ìœ„ì¹˜ ê³„ì‚°
                let insertAt = dropIndex;
                if (draggedIndex < dropIndex) insertAt--; 

                // í™”ë©´ìƒ Top(Front)ì— ë†“ìœ¼ë©´ ë°°ì—´ ì¸ë±ìŠ¤ ë’¤ìª½ìœ¼ë¡œ
                if (dropPos === 'top') insertAt++;

                // 3. ì‚½ì…
                state.layers.splice(insertAt, 0, itemToMove);
                
                renderLayerUI();
                draw();
            }
            return false;
        }
        
        // ===============================================

        function renderLayerUI() {
            layerListEl.innerHTML = '';
            
            // ì—­ìˆœ ë Œë”ë§
            state.layers.slice().reverse().forEach((layer, i) => {
                const realIndex = state.layers.length - 1 - i;
                const card = document.createElement('div');
                card.className = `layer-card ${layer.collapsed ? 'collapsed' : ''}`;
                // ì¹´ë“œëŠ” ë“œë˜ê·¸ ë¶ˆê°€ëŠ¥
                card.draggable = false; 
                card.dataset.index = realIndex; 

                // Drop Target ì—­í• ì€ ì¹´ë“œê°€ ìˆ˜í–‰
                card.addEventListener('dragover', handleDragOver);
                card.addEventListener('dragleave', handleDragLeave);
                card.addEventListener('drop', handleDrop);

                let typeName = 'ì•Œ ìˆ˜ ì—†ìŒ';
                let icon = '';
                if(layer.type === 'circle') { typeName = 'ì›'; icon = 'â—'; }
                else if(layer.type === 'square') { typeName = 'ì •ì‚¬ê°'; icon = 'â– '; }
                else if(layer.type === 'rect') { typeName = 'ì§ì‚¬ê°'; icon = 'â–¬'; }
                else if(layer.type === 'triangle') { typeName = 'ì‚¼ê°í˜•'; icon = 'â–²'; }
                else if(layer.type === 'image') { typeName = 'ì´ë¯¸ì§€'; icon = 'ğŸ“·'; }

                const isRect = layer.type === 'rect';
                const isImage = layer.type === 'image';

                card.innerHTML = `
                    <div class="layer-header" draggable="true" data-index="${realIndex}" onclick="toggleLayer(${layer.id})">
                        <div class="drag-handle" title="ìˆœì„œ ë³€ê²½">:::</div>
                        <span class="toggle-icon">â–¼</span>
                        <div class="layer-title">${icon} Layer ${realIndex + 1} (${typeName})</div>
                        <button class="delete-btn" onclick="event.stopPropagation(); removeLayer(${layer.id})">Ã—</button>
                    </div>

                    <div class="layer-content">
                        <div class="control-grid">
                            
                            <div class="full-width" style="border-bottom:1px dashed #eee; padding-bottom:10px; margin-bottom:5px;">
                                <label style="color:#007bff;">íŒ¨í„´ ê°„ê²© (Spacing)</label>
                                <div class="slider-input-group">
                                    <input type="range" class="input-slider-${layer.id}-gridSpacing" min="20" max="300" value="${layer.gridSpacing}" oninput="updateLayer(${layer.id}, 'gridSpacing', parseInt(this.value), 'slider')">
                                    <input type="number" class="input-number-${layer.id}-gridSpacing" value="${layer.gridSpacing}" oninput="updateLayer(${layer.id}, 'gridSpacing', parseInt(this.value), 'number')">
                                </div>
                            </div>

                            ${isImage ? `
                            <div class="full-width">
                                <label>ì´ë¯¸ì§€ íŒŒì¼ (JPG, PNG)</label>
                                <input type="file" accept="image/*" onchange="handleImageUpload(${layer.id}, this)">
                            </div>
                            ` : ''}

                            <div class="full-width" style="background:#f9f9f9; padding:8px; border-radius:5px; border:1px solid #eee;">
                                <label style="margin-bottom:8px;">ìœ„ì¹˜ ì´ë™ (Offset)</label>
                                <div class="slider-input-group">
                                    <span style="font-size:0.8em;width:15px;">X</span>
                                    <input type="range" class="input-slider-${layer.id}-offsetX" min="-200" max="200" value="${layer.offsetX}" oninput="updateLayer(${layer.id}, 'offsetX', parseInt(this.value), 'slider')">
                                    <input type="number" class="input-number-${layer.id}-offsetX" value="${layer.offsetX}" oninput="updateLayer(${layer.id}, 'offsetX', parseInt(this.value), 'number')">
                                </div>
                                <div class="slider-input-group" style="margin-top:5px;">
                                    <span style="font-size:0.8em;width:15px;">Y</span>
                                    <input type="range" class="input-slider-${layer.id}-offsetY" min="-200" max="200" value="${layer.offsetY}" oninput="updateLayer(${layer.id}, 'offsetY', parseInt(this.value), 'slider')">
                                    <input type="number" class="input-number-${layer.id}-offsetY" value="${layer.offsetY}" oninput="updateLayer(${layer.id}, 'offsetY', parseInt(this.value), 'number')">
                                </div>
                            </div>
                            <div class="half-width">
                                <label>ë¸”ë Œë“œ ëª¨ë“œ</label>
                                <select onchange="updateLayer(${layer.id}, 'blendMode', this.value)">
                                    <option value="source-over" ${layer.blendMode === 'source-over' ? 'selected' : ''}>Normal</option>
                                    <option value="multiply" ${layer.blendMode === 'multiply' ? 'selected' : ''}>Multiply</option>
                                    <option value="screen" ${layer.blendMode === 'screen' ? 'selected' : ''}>Screen</option>
                                    <option value="overlay" ${layer.blendMode === 'overlay' ? 'selected' : ''}>Overlay</option>
                                    <option value="difference" ${layer.blendMode === 'difference' ? 'selected' : ''}>Difference</option>
                                </select>
                            </div>
                            ${!isImage ? `
                            <div class="half-width">
                                <label class="label-with-tool">
                                    ìƒ‰ìƒ 
                                    <span class="shuffle-tool">
                                        <input type="checkbox" ${layer.randomColor ? 'checked' : ''} onchange="updateLayer(${layer.id}, 'randomColor', this.checked, 'checkbox')"> R
                                        <button class="shuffle-btn ${layer.randomColor ? 'active' : ''}" onclick="shuffleLayer(${layer.id})">ğŸ²</button>
                                    </span>
                                </label>
                                <input type="color" value="${layer.color}" oninput="updateLayer(${layer.id}, 'color', this.value)">
                            </div>
                            ` : `<div class="half-width"></div>`}
                            ${!isRect ? `
                            <div class="full-width">
                                <label class="label-with-tool">
                                    ë„í˜• í¬ê¸° (Size)
                                    <span class="shuffle-tool">
                                        <input type="checkbox" ${layer.randomSize ? 'checked' : ''} onchange="updateLayer(${layer.id}, 'randomSize', this.checked, 'checkbox')"> R
                                    </span>
                                </label>
                                <div class="slider-input-group">
                                    <input type="range" class="input-slider-${layer.id}-size" min="10" max="300" value="${layer.size}" oninput="updateLayer(${layer.id}, 'size', parseInt(this.value), 'slider')">
                                    <input type="number" class="input-number-${layer.id}-size" value="${layer.size}" oninput="updateLayer(${layer.id}, 'size', parseInt(this.value), 'number')">
                                </div>
                            </div>
                            ` : `
                            <div class="full-width">
                                 <label>ë„í˜• í¬ê¸° (Width / Height)</label>
                                 <div class="slider-input-group" style="margin-bottom:5px;">
                                    <span style="font-size:0.8em; width:15px;">W</span>
                                    <input type="range" min="10" max="300" value="${layer.width}" oninput="updateLayer(${layer.id}, 'width', parseInt(this.value))">
                                 </div>
                                 <div class="slider-input-group">
                                    <span style="font-size:0.8em; width:15px;">H</span>
                                    <input type="range" min="10" max="300" value="${layer.height}" oninput="updateLayer(${layer.id}, 'height', parseInt(this.value))">
                                 </div>
                            </div>
                            `}
                            <div class="full-width">
                                <label class="label-with-tool">
                                    íšŒì „ (Rotate)
                                    <span class="shuffle-tool">
                                        <input type="checkbox" ${layer.randomRotate ? 'checked' : ''} onchange="updateLayer(${layer.id}, 'randomRotate', this.checked, 'checkbox')"> R
                                    </span>
                                </label>
                                <div class="slider-input-group">
                                    <input type="range" class="input-slider-${layer.id}-rotation" min="0" max="360" value="${layer.rotation}" oninput="updateLayer(${layer.id}, 'rotation', parseInt(this.value), 'slider')">
                                    <input type="number" class="input-number-${layer.id}-rotation" value="${layer.rotation}" oninput="updateLayer(${layer.id}, 'rotation', parseInt(this.value), 'number')">
                                </div>
                            </div>
                        </div>
                    </div>
                `;
                
                layerListEl.appendChild(card);
                
                // [í•µì‹¬] í—¤ë”ì— ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì¶”ê°€ (Drag Source)
                const header = card.querySelector('.layer-header');
                header.addEventListener('dragstart', handleDragStart);
                header.addEventListener('dragend', handleDragEnd);
            });
        }

        function resizeCanvas() {
            canvas.width = container.offsetWidth;
            canvas.height = container.offsetHeight;
            draw();
        }

        // ê·¸ë¦¬ê¸° ë¡œì§ (ë™ì¼)
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = "#ffffff";
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            state.layers.forEach(layer => {
                ctx.save();
                ctx.globalCompositeOperation = layer.blendMode;

                const spacing = layer.gridSpacing;
                const cols = Math.ceil(canvas.width / spacing) + 2;
                const rows = Math.ceil(canvas.height / spacing) + 2;

                for (let x = -1; x < cols; x++) {
                    for (let y = -1; y < rows; y++) {
                        const cellX = x * spacing;
                        const cellY = y * spacing;
                        const randIndex = Math.abs((x * 15485863 + y * 32452843)) % CACHE_SIZE;
                        const cachedRand = layer.randomData[randIndex];

                        const centerX = cellX + (spacing / 2) + layer.offsetX;
                        const centerY = cellY + (spacing / 2) + layer.offsetY;

                        ctx.translate(centerX, centerY);

                        let angle = 0;
                        if (layer.randomRotate) angle = cachedRand.angle;
                        else angle = layer.rotation * (Math.PI / 180);
                        ctx.rotate(angle);

                        let fillColor = layer.color;
                        if (layer.randomColor) fillColor = cachedRand.color;
                        ctx.fillStyle = fillColor;
                        
                        let scaleFactor = 1;
                        if (layer.randomSize) scaleFactor = cachedRand.scale;

                        ctx.beginPath();
                        ctx.globalAlpha = 0.9; 

                        if (layer.type === 'circle') {
                            const r = (spacing * (layer.size / 100) * scaleFactor) / 2;
                            ctx.arc(0, 0, Math.max(0, r), 0, Math.PI * 2);
                            ctx.fill();
                        } 
                        else if (layer.type === 'square') {
                            const s = spacing * (layer.size / 100) * scaleFactor;
                            ctx.rect(-s/2, -s/2, s, s);
                            ctx.fill();
                        } 
                        else if (layer.type === 'rect') {
                            const w = (layer.width / 100) * spacing * scaleFactor;
                            const h = (layer.height / 100) * spacing * scaleFactor;
                            ctx.rect(-w/2, -h/2, w, h);
                            ctx.fill();
                        }
                        else if (layer.type === 'triangle') {
                            const s = spacing * (layer.size / 100) * scaleFactor;
                            const h = s * (Math.sqrt(3)/2);
                            ctx.moveTo(0, -h/2);
                            ctx.lineTo(s/2, h/2);
                            ctx.lineTo(-s/2, h/2);
                            ctx.closePath();
                            ctx.fill();
                        }
                        else if (layer.type === 'image') {
                            if (layer.imgObj) {
                                const s = spacing * (layer.size / 100) * scaleFactor;
                                ctx.drawImage(layer.imgObj, -s/2, -s/2, s, s);
                            } else {
                                ctx.strokeStyle = "#ccc";
                                ctx.strokeRect(-10, -10, 20, 20);
                                ctx.fillStyle = "#999";
                                ctx.fillText("Img", -8, 4);
                            }
                        }

                        ctx.rotate(-angle);
                        ctx.translate(-centerX, -centerY);
                    }
                }
                ctx.restore();
            });
        }

        function downloadImage() {
            const link = document.createElement('a');
            link.download = `pattern_pro_v17_${Date.now()}.jpg`;
            link.href = canvas.toDataURL('image/jpeg', 1.0);
            link.click();
        }

        init();
    </script>
</body>
</html>